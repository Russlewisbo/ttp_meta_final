
---
title: "Time to Positivity & Antibiotic Failure in Bacteremia: Bayesian Meta-Analysis"
author: "Generated by Databot"
date: "2026-02-13"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-summary: "Show code"
    theme: cosmo
    fig-width: 9
    fig-height: 6
    embed-resources: true
execute:
  warning: false
  message: false
bibliography: references.bib
---

# Introduction

## Background

Blood culture time to positivity (TTP) — the interval between blood culture incubation and detection of microbial growth — has emerged as a potential prognostic marker in bacteremia. Shorter TTP is hypothesized to reflect higher bacterial inocula, which may signal more severe infection, greater risk of treatment failure, and higher mortality.

This meta-analysis systematically synthesizes the evidence on the association between short TTP and two primary clinical outcomes:

1. **Mortality** (all-cause, typically 30-day or in-hospital)
2. **Persistent bacteremia** (including microbiological clearance failure)

## Analytical Approach

We employ a Bayesian random-effects framework using `brms` with weakly informative priors, complemented by frequentist models via `metafor` for validation. The analysis includes:

- Effect size computation from heterogeneous reporting formats (2×2 tables, adjusted/unadjusted OR/HR/RR, continuous TTP associations)
- Random-effects pooling with REML (frequentist) and Bayesian estimation
- Publication bias assessment (funnel plots, Egger's test, trim-and-fill)
- Sensitivity analyses (outlier exclusion, prior specification)
- Meta-regression for moderator effects (pathogen class, organism, risk of bias, blood culture system)

# Data Loading & Preparation

## Load Packages

```{r}
#| label: setup
#| code-fold: false

library(tidyverse)
library(readxl)
library(janitor)
library(metafor)
library(brms)
library(posterior)
library(bayesplot)
library(ggdist)
library(patchwork)

color_scheme_set("viridis")
theme_set(theme_minimal(base_size = 12))

# Detect Stan backend
stan_backend <- if (requireNamespace("cmdstanr", quietly = TRUE)) "cmdstanr" else "rstan"
```

## Load Database

The extraction database is stored as an Excel workbook with one sheet per table, following the relational structure outlined in the analysis protocol.

```{r}
#| label: load-data

path <- "/Users/russelllewis/Desktop/ttp metaanalysis/TTP_MetaAnalysis_Extraction_Complete.xlsx"

tbl_study      <- read_excel(path, sheet = "tbl_study") |> clean_names()
tbl_population <- read_excel(path, sheet = "tbl_population") |> clean_names()
tbl_ttp        <- read_excel(path, sheet = "tbl_ttp") |> clean_names()
tbl_outcomes   <- read_excel(path, sheet = "tbl_outcomes") |> clean_names()
```

```{r}
#| label: data-dimensions

tibble(
  Table = c("tbl_study", "tbl_population", "tbl_ttp", "tbl_outcomes"),
  Rows = c(nrow(tbl_study), nrow(tbl_population), nrow(tbl_ttp), nrow(tbl_outcomes)),
  Columns = c(ncol(tbl_study), ncol(tbl_population), ncol(tbl_ttp), ncol(tbl_outcomes))
)
```

## Data Cleaning

### Remove Non-PICO Entries and Harmonize Outcome Types

Rows flagged as `[NON-PICO]` in the notes field represent outcomes outside the primary review question (e.g., septic shock, endocarditis as a diagnostic marker, catheter-related BSI). These are excluded before analysis.

```{r}
#| label: clean-outcomes

outcomes_clean <- tbl_outcomes |>
  # Remove NON-PICO

  filter(is.na(notes) | !str_detect(notes, "\\[NON-PICO\\]")) |>
  # Remove row with no outcome type
  filter(!is.na(outcome_type)) |>
  # Harmonize outcome types
  mutate(
    outcome_type_clean = case_when(
      outcome_type %in% c("mortality", "in_hospital_mortality") ~ "mortality",
      outcome_type %in% c("persistent_bacteremia", "bacteremia_clearance",
                          "microbiological_clearance", "bacteremia_classification") ~ "persistent_bacteremia",
      outcome_type %in% c("endocarditis", "infective_endocarditis",
                          "endovascular_infection") ~ "endocarditis_endovascular",
      outcome_type %in% c("sepsis_severity_mortality", "disease_severity",
                          "organ_dysfunction") ~ "severity",
      TRUE ~ outcome_type
    )
  ) |>
  # Classify effect size source
  mutate(
    has_2x2 = !is.na(events_short_ttp) & !is.na(events_long_ttp) &
              !is.na(n_short_ttp) & !is.na(n_long_ttp),
    has_effect_ci = !is.na(effect_estimate) & !is.na(ci_lower) & !is.na(ci_upper) &
                    effect_measure %in% c("OR", "HR", "RR"),
    has_or_per_hour = !is.na(or_per_hour) & !is.na(or_per_hour_ci_low) & !is.na(or_per_hour_ci_high),
    es_source = case_when(
      has_2x2 & has_effect_ci & adjusted ~ "reported_adjusted",
      has_2x2 & has_effect_ci & !adjusted ~ "reported_unadjusted",
      has_2x2 ~ "two_by_two",
      has_effect_ci & adjusted ~ "reported_adjusted",
      has_effect_ci ~ "reported_unadjusted",
      has_or_per_hour ~ "continuous_converted",
      TRUE ~ "insufficient_data"
    )
  )
```

```{r}
#| label: cleaning-summary

cat("Original outcome rows:", nrow(tbl_outcomes), "\n")
cat("After removing NON-PICO:", nrow(outcomes_clean), "\n\n")
outcomes_clean |> count(outcome_type_clean, sort = TRUE)
```

## Effect Size Computation

Effect sizes are computed as log-odds ratios (log-OR) with associated sampling variances, following the hierarchy specified in the protocol:

1. **Reported adjusted estimates preferred** over unadjusted
2. **2×2 tables** used when no reported effect available
3. **Continuous TTP effects** (OR per hour) kept separate

### From 2×2 Tables

```{r}
#| label: es-2x2

rows_2x2 <- outcomes_clean |> filter(es_source == "two_by_two")

es_2x2 <- escalc(
  measure = "OR",
  ai = rows_2x2$events_short_ttp,
  bi = rows_2x2$n_short_ttp - rows_2x2$events_short_ttp,
  ci = rows_2x2$events_long_ttp,
  di = rows_2x2$n_long_ttp - rows_2x2$events_long_ttp,
  data = rows_2x2
) |>
  as.data.frame() |>
  mutate(yi = as.numeric(yi), vi = as.numeric(vi), sei = sqrt(vi))
```

### From Reported Effect Estimates (OR/HR/RR with CI)

```{r}
#| label: es-reported

rows_reported <- outcomes_clean |>
  filter(es_source %in% c("reported_adjusted", "reported_unadjusted"))

es_reported <- rows_reported |>
  mutate(
    yi = log(effect_estimate),
    sei = (log(ci_upper) - log(ci_lower)) / (2 * 1.96),
    vi = sei^2
  )
```

### From Continuous TTP (OR per Hour)

```{r}
#| label: es-continuous

es_continuous_1 <- outcomes_clean |>
  filter(es_source == "continuous_converted") |>
  mutate(
    yi = log(or_per_hour),
    sei = (log(or_per_hour_ci_high) - log(or_per_hour_ci_low)) / (2 * 1.96),
    vi = sei^2
  )

# SantosPatarroyo2025 has beta_per_hour (already log-OR scale)
es_continuous_2 <- outcomes_clean |>
  filter(study_id == "SantosPatarroyo2025") |>
  mutate(
    yi = beta_per_hour,
    sei = (ci_upper - ci_lower) / (2 * 1.96),
    vi = sei^2,
    es_source = "continuous_converted"
  )
```

### Combine and Deduplicate

```{r}
#| label: combine-es

common_cols <- c("study_id", "arm_id", "outcome_type_clean", "outcome_definition",
                 "outcome_timepoint_days", "effect_measure", "effect_estimate",
                 "adjusted", "adjustment_vars", "yi", "sei", "vi", "es_source")

tbl_es_combined <- bind_rows(
  es_2x2 |> select(any_of(common_cols)),
  es_reported |> select(any_of(common_cols)),
  bind_rows(es_continuous_1, es_continuous_2) |> select(any_of(common_cols))
)

# Deduplication rules:
# - Prefer adjusted over unadjusted (Cilloniz2017, Hou2023)
# - Remove extreme sparse-cell row (Melling2019 OR=1722)
tbl_es <- tbl_es_combined |>
  filter(!(study_id == "Cilloniz2017" & adjusted == FALSE)) |>
  filter(!(study_id == "Hou2023" & adjusted == FALSE)) |>
  filter(!(study_id == "Melling2019" & yi > 5))
```

### Merge Moderator Variables

```{r}
#| label: merge-moderators

tbl_es <- tbl_es |>
  left_join(
    tbl_population |>
      select(study_id, n_total, pathogen_class, pathogen_species,
             infection_source, source_control, pct_icu,
             severity_score_type, pct_appropriate_empiric, blood_culture_system),
    by = "study_id"
  ) |>
  left_join(
    tbl_ttp |> select(study_id, ttp_cutpoint_hours, ttp_cutpoint_basis),
    by = "study_id"
  ) |>
  left_join(
    tbl_study |> select(study_id, rob_overall, pub_year, country, study_design),
    by = "study_id"
  ) |>
  mutate(
    organism_saureus = str_detect(pathogen_species, regex("aureus", ignore_case = TRUE)),
    ni = n_total,
    es_id = row_number(),
    rob_binary = ifelse(rob_overall == "low", "low", "moderate_high"),
    blood_culture_system_clean = case_when(
      str_detect(blood_culture_system, regex("BacTALERT|BACT/ALERT|BacT/Alert", ignore_case = TRUE)) ~ "BacTALERT",
      str_detect(blood_culture_system, regex("BACTEC", ignore_case = TRUE)) ~ "BACTEC",
      str_detect(blood_culture_system, regex("VersaTREK", ignore_case = TRUE)) ~ "VersaTREK",
      str_detect(blood_culture_system, regex("automated|other", ignore_case = TRUE)) ~ "other",
      blood_culture_system == "NR" ~ "NR",
      TRUE ~ NA_character_
    ),
    bcs_binary = case_when(
      blood_culture_system_clean == "BACTEC" ~ "BACTEC",
      blood_culture_system_clean == "BacTALERT" ~ "BacTALERT",
      TRUE ~ "other"
    )
  )
```

```{r}
#| label: es-summary-table

cat("Final tbl_es:", nrow(tbl_es), "effect sizes from", n_distinct(tbl_es$study_id), "studies\n\n")
tbl_es |> count(outcome_type_clean, es_source) |>
  pivot_wider(names_from = es_source, values_from = n, values_fill = 0)
```

# Descriptive Summary

## Study Characteristics

```{r}
#| label: tbl-study-chars
#| tbl-cap: "Study characteristics overview"

tbl_study |>
  summarise(
    `N studies` = n(),
    `Publication years` = paste0(min(pub_year), "–", max(pub_year)),
    `Prospective (%)` = round(100 * mean(study_design == "prospective_cohort"), 1),
    `Single-center (%)` = round(100 * mean(single_center, na.rm = TRUE), 1),
    `ROB low (%)` = round(100 * mean(rob_overall == "low"), 1),
    `ROB moderate (%)` = round(100 * mean(rob_overall == "moderate"), 1)
  ) |>
  pivot_longer(everything(), names_to = "Characteristic", values_to = "Value")
```

## Effect Size Distributions

```{r}
#| label: fig-es-distributions
#| fig-cap: "Distribution of log-OR effect sizes by outcome"
#| fig-height: 5

tbl_es |>
  filter(es_source != "continuous_converted") |>
  ggplot(aes(x = yi, fill = outcome_type_clean)) +
  geom_histogram(bins = 20, alpha = 0.7, position = "identity") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~outcome_type_clean, scales = "free_y") +
  labs(x = "Log Odds Ratio", y = "Count", fill = "Outcome") +
  scale_fill_manual(values = c("mortality" = "steelblue", "persistent_bacteremia" = "darkorange")) +
  theme(legend.position = "none")
```

## Moderator Completeness

```{r}
#| label: tbl-moderator-completeness
#| tbl-cap: "Moderator variable completeness in tbl_es"

tbl_es |>
  summarise(
    across(c(pathogen_class, organism_saureus, infection_source,
             rob_overall, pub_year, blood_culture_system_clean, ttp_cutpoint_hours),
           ~sum(!is.na(.)))
  ) |>
  pivot_longer(everything(), names_to = "Moderator", values_to